1.Сортировка выбором - это простой алгоритм сортировки, который на каждом шаге находит минимальный (или максимальный) элемент из неотсортированной части массива и помещает его в конец отсортированной части.
Алгоритм состоит из двух вложенных циклов:
1.	Внешний цикл выполняется n-1 раз (проходит по всем элементам кроме последнего)
2.	Внутренний цикл на i-ой итерации внешнего цикла выполняется n-i-1 раз
3.	Временная сложность: O(n²)


2. Сортировка обменом (пузырьком) - это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.
Объяснение временной сложности
В худшем случае (массив отсортирован в обратном порядке):
•	Нужно n-1 проходов по массиву
•	На каждом проходе выполняется n-1, n-2, ..., 1 сравнений
•	Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
В лучшем случае (массив уже отсортирован) в оптимизированной версии:
•	Достаточно одного прохода для проверки
•	Количество сравнений: n-1

3.Сортировка вставками - это алгоритм сортировки, который строит отсортированную последовательность постепенно, на каждом шаге вставляя очередной элемент в правильную позицию среди уже отсортированных элементов.
Объяснение временной сложности
В худшем случае (массив отсортирован в обратном порядке):
•	Каждый новый элемент нужно сравнивать со всеми элементами в отсортированной части
•	Для i-го элемента выполняется i сравнений и сдвигов
•	Общее количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 ≈ n²/2
В лучшем случае (массив уже отсортирован):
•	Каждый элемент сразу находится на своем месте
•	Только 1 сравнение на элемент
•	Количество операций: n-1

4.Сортировка слиянием - это алгоритм сортировки, использующий стратегию "разделяй и властвуй". Он рекурсивно разделяет массив на две половины, сортирует каждую половину, а затем объединяет отсортированные половины в один отсортированный массив.
Объяснение временной сложности
•	Массив делится пополам до тех пор, пока не останутся массивы размером 1
•	Количество делений: log₂n
Работа на каждом уровне:
•	На каждом уровне выполняется слияние всех элементов (n операций)
•	Всего уровней: log n
Общая сложность: n × log n = O(n log n)

5.Сортировка Шелла - это алгоритм сортировки, который является обобщением сортировки вставками. Он сортирует элементы, расположенные далеко друг от друга, постепенно уменьшая расстояние между сравниваемыми элементами. Алгоритм использует последовательность промежутков (gaps), начиная с большого и заканчивая 1.
Объяснение временной сложности:
•	Зависит от выбора последовательности шагов.
•	В лучшем случае: O(n log n), в худшем: O(n^2).
•	Временная сложность: O(n^2) (в худшем случае)

6. Быстрая сортировка - это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй". Алгоритм выбирает опорный элемент (pivot), разделяет массив на две части относительно этого элемента и рекурсивно сортирует каждую часть.
Временная сложность
•	Худший случай: O(n²)
•	Лучший случай: O(n log n)
Объяснение временной сложности
Лучший/Средний случай O(n log n):
•	На каждом уровне рекурсии массив делится примерно пополам
•	Глубина рекурсии: log n уровней
•	На каждом уровне выполняется O(n) операций
•	Итого: n × log n = O(n log n)

7. Пирамидальная сортировка - это алгоритм сортировки, который использует структуру данных "двоичная куча" (binary heap). Алгоритм состоит из двух этапов: построение max-кучи из массива и последовательное извлечение максимальных элементов.
Временная сложность
•	Худший случай: O(n log n)
•	Лучший случай: O(n log n)
Объяснение временной сложности:
•	Построение кучи: O(n) операций
•	Извлечение каждого элемента: O(log n) операций
•	Для n элементов: n × log n = O(n log n)

8. Последовательный поиск - это простейший алгоритм поиска, который последовательно проверяет каждый элемент массива или списка до тех пор, пока не найдет искомый элемент или не проверит все элементы.
Временная сложность
o	Худший случай: O(n)
o	Лучший случай: O(1)
Объяснение временной сложности:
•	В среднем нужно проверить n/2 элементов
•	Константа 1/2 отбрасывается в O-нотации

9. Бинарный поиск -  это эффективный алгоритм поиска элемента в отсортированном массиве, который на каждом шаге делит область поиска пополам.
Временная сложность
•	Худший случай: O(log n)
•	Лучший случай: O(1)
Объяснение временной сложности:
•	На каждом шаге область поиска уменьшается вдвое
•	Максимальное количество шагов: log₂n

10. Интерполирующий поиск – это улучшенный алгоритм поиска в отсортированном массиве, который использует значения элементов для предсказания позиции искомого элемента. В отличие от бинарного поиска, который всегда делит массив пополам, интерполирующий поиск пытается "угадать" ближайшую позицию элемента.
Временная сложность
o	Худший случай: O(n)
o	Лучший случай: O(log log n)
Объяснение временной сложности:
•	При неравномерном распределении данных алгоритм может деградировать до последовательного поиска
•	Количество шагов растет как логарифм от логарифма n

11. Фибоначчи поиск – это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для разделения массива. Это улучшение бинарного поиска, которое использует сложение и вычитание вместо деления, что может быть эффективнее на некоторых системах.
Временная сложность
o	Худший случай: O(log n)
o	Лучший случай: O(1)
Объяснение временной сложности:
•	Количество шагов пропорционально log₂n
•	Аналогично бинарному поиску, но с другим механизмом деления

